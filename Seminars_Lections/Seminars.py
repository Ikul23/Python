# # # # # # # ДЗ 1

# # # # # # # Задача 10: На столе лежат n монеток. Некоторые из них лежат вверх
# # # # # # # решкой, а некоторые – гербом. Определите минимальное число
# # # # # # # монеток, которые нужно перевернуть, чтобы все монетки были
# # # # # # # повернуты вверх одной и той же стороной. Выведите минимальное
# # # # # # # количество монет, которые нужно перевернуть.
# # # # # # # 5 -> 1 0 1 1 0
# # # # # # # 2
# # # # # # # qm = int(input('введите количество монет'))

# # # # # # # print(*range(0,qm+1),1)

# # # # # # # Петя и Катя – брат и сестра. Петя – студент, а Катя –
# # # # # # # школьница. Петя помогает Кате по математике. Он задумывает два
# # # # # # # натуральных числа X и Y (X,Y≤1000), а Катя должна их отгадать. Для
# # # # # # # этого Петя делает две подсказки. Он называет сумму этих чисел S и их
# # # # # # # произведение P. Помогите Кате отгадать задуманные Петей числа.

# # # # # # # sum = int(input ("Введите сумму чисел x и y"))
# # # # # # # mult = int(input ("Введите произведение чисел x и y"))

# # # # # # # if sum - x 

# # # # # # # n = int(input ('Введите натуральное число: '))
# # # # # # # # p = n // 4
# # # # # # # # s = n // 4
# # # # # # # # k = n - p - s
# # # # # # # print (n//4, n-(n//4*2), n//4, end='')
# # # # # n = 385916
# # # # # n1 = n//100000 + (n//10000)%10 + (n//1000)%10
# # # # # n2 = (n//100)%10 + (n//10)%10 + n%10 
# # # # # if n1 == n2:
# # # # #     print('yes')
# # # # # else:
# # # # #     print('no')
# # # # # Задача 3: Требуется вывести все целые степени двойки (т.е. числа вида 2k),
# # # # # не превосходящие числаN.
# # # # n = 16
# # # # # k = -1
# # # # # p = 0
# # # # # while p < n:        
# # # # #     k = k + 1   
# # # # #     p =  2 ** k
# # # # #     print(p)   
# # # # i = 0
# # # # while 2 ** i <= n:
# # # #     print(2 ** i)
# # # #     i += 1



# # # # # # # ДЗ 2
# # # # # # # Задача8
# # # # # # # n = int (input ('Введите количество долек по горизонтали:'))
# # # # # # # m = int (input ('Введите количество долек по вертикали:'))
# # # # # # # k = int (input ('Введите количество долек:'))
# # # # # # # if n*m >= k and (n*m % k == 0 or (n*m - k) % 2 == 0):
# # # # # # #     print ('Yes')
# # # # # # # else:
# # # # # # #     print ('No')

# # # Напишите программу, которая принимает от пользователя число n, кол-во элементов списка.
# # # # Затем пользователь вводит на каждой новой строчке число, которое необходимо сохранить в список.
# # # n = int(input("Введите кол-во элементов списка: "))
# # # data = []
# # # for i in range(n):
# # #     data.append(int(input("Введите число: ")))
# # #     # insert(position, element)
# # # print(*data)

# # # List comprehansive
# # # print(*[i for i in range(5)])
# # # print(*[(i, i**2) for i in range(5)]) # запись через кортеж
# # # print(*[i for i in range(5) if i%2==0])

# # # data = [int(i) for i in input('Введите числа: ').split()]
# # # print(len(set(data)))

# # # Задача: Напишите программу для печати всех уникальных
# # # значений в словаре.
# # # Input: [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"},
# # # {"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII
# # # ":" S007 "}]
# # # Output: {'S005', 'S002', 'S007', 'S001', 'S009'}

# # data = [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"}, {"VI": "S005"},
# # {"VII": "S005"}, {" V ":"S009"}, {" VIII":"S007"}]

# # # print(data[0]["V"]) # выводит значение по ключу в консоль
# # result = set () # создаем пустое множество для решения задачи
# # for j in data:
# #     for i in j:
# #         # print(i) # выводит все ключи в словаре
# #         # print(i, j[i]) # выводит все ключи в словаре
# #         # print(j[i]) # выводит значение по ключу в консоль по всему словарю
# #         result.add(j[i]) # переводит словарь во множество
# # print(result)

# # Задача №23. Общее обсуждение
# # Дан массив, состоящий из целых чисел. Напишите
# # программу, которая подсчитает количество
# # элементов массива, больших предыдущего (элемента
# # с предыдущим номером)
# # Input: [0, -1, 5, 2, 3]
# # data = [int(i) for i in input('Введите числа:').split] # переводит введенные в консоль числа в виде строки в список
# # result = [data[i-1]< data[i] for i in range(1, len(data))] # начинаем не с нулевого элемента , иначе в начале будет с 
# # # print(sum(result))
   
# # data = [int(i) for i in input("Введите числа: ").split()]
# # result = [data[i - 1] < data[i] for i in range(1, len(data))]
# # print(sum(result))       

# # У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине
# # программы используется множество раз и вы не хотите ничего сломать):
# # transformation = <???>
# # values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# # transormed_values = list(map(transformation, values))
# # Единственный способ вашего взаимодействия с этим кодом - посредством задания
# # функции transformation.
# # Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать
# # список значений, а нужно получить его как есть.
# # Напишите такое лямбда-выражение transformation, чтобы transformed_values получился
# # копией values.
# # values = [1, 23, 42, 'asdfg']

# # tran_val = list(map(lambda x: x,  values))
# # if values == tran_val:
# #     print('ok')
# # else:
# #     print('fail')

# # Задача: Планеты вращаются вокруг звезд по эллиптическим орбитам.
# # Назовем самой далекой планетой ту, орбита которой имеет
# # самую большую площадь. Напишите функцию
# # find_farthest_orbit(list_of_orbits), которая среди списка орбит
# # планет найдет ту, по которой вращается самая далекая
# # планета. Круговые орбиты не учитывайте: вы знаете, что у
# # вашей звезды таких планет нет, зато искусственные спутники
# # были были запущены на круговые орбиты. Результатом
# # функции должен быть кортеж, содержащий длины полуосей
# # эллипса орбиты самой далекой планеты. Каждая орбита
# # представляет из себя кортеж из пары чисел - полуосей ее
# # эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b,
# # где a и b - длины полуосей эллипса. При решении задачи
# # используйте списочные выражения. Подсказка: проще всего
# # будет найти эллипс в два шага: сначала вычислить самую
# # большую площадь эллипса, а затем найти и сам эллипс,
# # имеющий такую площадь. Гарантируется, что самая далекая
# # планета ровно одна

# # def find_farthest_orbit(list_orbits):
# #     list_S = [S:= list_orbits[i][0]*list_orbits[i][1] for i in range(len(list_orbits)) if list_orbits[i][0] != list_orbits[i][1]]
# #     num_list_S = list(enumerate(list_S,0))
# #     max_i_S = max(num_list_S, key = lambda i: i[1])
# #     return list_orbits[max_i_S[0]]

# # orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# # print(*find_farthest_orbit(orbits))

# def find_farthest_orbit(orbits):
#     list_square = [(i[0] != i[1]) * i[0] * i[1] for i in orbits]
#     return orbits[list_square.index(max(list_square))]


# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# #            0         1        2       3       4
# # list_square = [3, 25, 14, 0, 12]
# #                0   1   2   3  4

# print(*find_farthest_orbit(orbits))

def same_by(characteristic, objects):
    return len(set(list(map(characteristic, objects)))) in (0, 1)


values = [3, 6, 9, 12, 15, 16]
if same_by(lambda x: x % 3, values):
    print('same')
else:
    print('different')
