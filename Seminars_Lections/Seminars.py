# # # # # # # # ДЗ 1


# # # # # # # # Петя и Катя – брат и сестра. Петя – студент, а Катя –
# # # # # # # # школьница. Петя помогает Кате по математике. Он задумывает два
# # # # # # # # натуральных числа X и Y (X,Y≤1000), а Катя должна их отгадать. Для
# # # # # # # # этого Петя делает две подсказки. Он называет сумму этих чисел S и их
# # # # # # # # произведение P. Помогите Кате отгадать задуманные Петей числа.

# # # # # # # # sum = int(input ("Введите сумму чисел x и y"))
# # # # # # # # mult = int(input ("Введите произведение чисел x и y"))

# # # # # # # # if sum - x 

# # # # # # # # n = int(input ('Введите натуральное число: '))
# # # # # # # # # p = n // 4
# # # # # # # # # s = n // 4
# # # # # # # # # k = n - p - s
# # # # # # # # print (n//4, n-(n//4*2), n//4, end='')
# # # # # # n = 385916
# # # # # # n1 = n//100000 + (n//10000)%10 + (n//1000)%10
# # # # # # n2 = (n//100)%10 + (n//10)%10 + n%10 
# # # # # # if n1 == n2:
# # # # # #     print('yes')
# # # # # # else:
# # # # # #     print('no')
# # # # # # Задача 3: Требуется вывести все целые степени двойки (т.е. числа вида 2k),
# # # # # # не превосходящие числаN.
# # # # # n = 16
# # # # # # k = -1
# # # # # # p = 0
# # # # # # while p < n:        
# # # # # #     k = k + 1   
# # # # # #     p =  2 ** k
# # # # # #     print(p)   
# # # # # i = 0
# # # # # while 2 ** i <= n:
# # # # #     print(2 ** i)
# # # # #     i += 1



# # # # # # # # ДЗ 2
# # # # # # # # Задача8
# # # # # # # # n = int (input ('Введите количество долек по горизонтали:'))
# # # # # # # # m = int (input ('Введите количество долек по вертикали:'))
# # # # # # # # k = int (input ('Введите количество долек:'))
# # # # # # # # if n*m >= k and (n*m % k == 0 or (n*m - k) % 2 == 0):
# # # # # # # #     print ('Yes')
# # # # # # # # else:
# # # # # # # #     print ('No')

# # # # Напишите программу, которая принимает от пользователя число n, кол-во элементов списка.
# # # # # Затем пользователь вводит на каждой новой строчке число, которое необходимо сохранить в список.
# # # # n = int(input("Введите кол-во элементов списка: "))
# # # # data = []
# # # # for i in range(n):
# # # #     data.append(int(input("Введите число: ")))
# # # #     # insert(position, element)
# # # # print(*data)

# # # # List comprehansive
# # # # print(*[i for i in range(5)])
# # # # print(*[(i, i**2) for i in range(5)]) # запись через кортеж
# # # # print(*[i for i in range(5) if i%2==0])

# # # # data = [int(i) for i in input('Введите числа: ').split()]
# # # # print(len(set(data)))

# # # # Задача: Напишите программу для печати всех уникальных
# # # # значений в словаре.
# # # # Input: [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"},
# # # # {"VI": "S005"}, {"VII": " S005 "}, {" V ":" S009 "}, {" VIII
# # # # ":" S007 "}]
# # # # Output: {'S005', 'S002', 'S007', 'S001', 'S009'}

# # # data = [{"V": "S001"}, {"V": "S002"}, {"VI": "S001"}, {"VI": "S005"},
# # # {"VII": "S005"}, {" V ":"S009"}, {" VIII":"S007"}]

# # # # print(data[0]["V"]) # выводит значение по ключу в консоль
# # # result = set () # создаем пустое множество для решения задачи
# # # for j in data:
# # #     for i in j:
# # #         # print(i) # выводит все ключи в словаре
# # #         # print(i, j[i]) # выводит все ключи в словаре
# # #         # print(j[i]) # выводит значение по ключу в консоль по всему словарю
# # #         result.add(j[i]) # переводит словарь во множество
# # # print(result)

# # # Задача №23. Общее обсуждение
# # # Дан массив, состоящий из целых чисел. Напишите
# # # программу, которая подсчитает количество
# # # элементов массива, больших предыдущего (элемента
# # # с предыдущим номером)
# # # Input: [0, -1, 5, 2, 3]
# # # data = [int(i) for i in input('Введите числа:').split] # переводит введенные в консоль числа в виде строки в список
# # # result = [data[i-1]< data[i] for i in range(1, len(data))] # начинаем не с нулевого элемента , иначе в начале будет с 
# # # # print(sum(result))
   
# # # data = [int(i) for i in input("Введите числа: ").split()]
# # # result = [data[i - 1] < data[i] for i in range(1, len(data))]
# # # print(sum(result))       

# # # У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине
# # # программы используется множество раз и вы не хотите ничего сломать):
# # # transformation = <???>
# # # values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# # # transormed_values = list(map(transformation, values))
# # # Единственный способ вашего взаимодействия с этим кодом - посредством задания
# # # функции transformation.
# # # Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать
# # # список значений, а нужно получить его как есть.
# # # Напишите такое лямбда-выражение transformation, чтобы transformed_values получился
# # # копией values.
# # # values = [1, 23, 42, 'asdfg']

# # # tran_val = list(map(lambda x: x,  values))
# # # if values == tran_val:
# # #     print('ok')
# # # else:
# # #     print('fail')

# # # Задача: Планеты вращаются вокруг звезд по эллиптическим орбитам.
# # # Назовем самой далекой планетой ту, орбита которой имеет
# # # самую большую площадь. Напишите функцию
# # # find_farthest_orbit(list_of_orbits), которая среди списка орбит
# # # планет найдет ту, по которой вращается самая далекая
# # # планета. Круговые орбиты не учитывайте: вы знаете, что у
# # # вашей звезды таких планет нет, зато искусственные спутники
# # # были были запущены на круговые орбиты. Результатом
# # # функции должен быть кортеж, содержащий длины полуосей
# # # эллипса орбиты самой далекой планеты. Каждая орбита
# # # представляет из себя кортеж из пары чисел - полуосей ее
# # # эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b,
# # # где a и b - длины полуосей эллипса. При решении задачи
# # # используйте списочные выражения. Подсказка: проще всего
# # # будет найти эллипс в два шага: сначала вычислить самую
# # # большую площадь эллипса, а затем найти и сам эллипс,
# # # имеющий такую площадь. Гарантируется, что самая далекая
# # # планета ровно одна

# # # def find_farthest_orbit(list_orbits):
# # #     list_S = [S:= list_orbits[i][0]*list_orbits[i][1] for i in range(len(list_orbits)) if list_orbits[i][0] != list_orbits[i][1]]
# # #     num_list_S = list(enumerate(list_S,0))
# # #     max_i_S = max(num_list_S, key = lambda i: i[1])
# # #     return list_orbits[max_i_S[0]]

# # # orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# # # print(*find_farthest_orbit(orbits))

# # def find_farthest_orbit(orbits):
# #     list_square = [(i[0] != i[1]) * i[0] * i[1] for i in orbits]
# #     return orbits[list_square.index(max(list_square))]


# # orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
# # #            0         1        2       3       4
# # # list_square = [3, 25, 14, 0, 12]
# # #                0   1   2   3  4

# # print(*find_farthest_orbit(orbits))

# def same_by(characteristic, objects):
#     return len(set(list(map(characteristic, objects)))) in (0, 1)


# values = [3, 6, 9, 12, 15, 16]
# if same_by(lambda x: x % 3, values):
#     print('same')
# else:
#     print('different')

# # Задача №39. Решение в группах Даны два массива чисел. Требуется вывести те элементы первого массива 
# # (в том порядке, в каком они идут в первом массиве), которых нет во втором массиве. Пользователь вводит  
# # число N - количество элементов в первом массиве, затем N чисел - элементы массива. Затем число M - 
# # количество элементов во втором массиве. Затем элементы второго массива 

# # sp1 = [3, 1, 3, 4, 2, 4, 12]
# # sp2 = [4, 15, 43, 1, 15, 1]

# # print([i for i in sp1 if i not in sp2])
# # print([i for i in sp1 if i not in set(sp2)])

# # Задача №41. Решение в группах Дан массив, состоящий из целых чисел. Напишите программу, 
# # которая в данном массиве определит количество элементов, у которых два соседних и, при этом, 
# # оба соседних элемента меньше данного. Сначала вводится число N — количество элементов в массиве  
# # Далее записаны N чисел — элементы массива. Массив состоит из целых чисел. 

# # def find_champ(sp, index):
# #     if sp[index] > sp[index+1] and sp[index] > sp[index-1]:
# #         return True
# #     return False

# # def find_champ2(sp, index):
# #     if sp[index] > sp[(index+1) % len(sp)] and sp[index] > sp[index-1]:
# #         return True
# #     return False




# # sp1 = [1,2,3,4,5]  # 0

# # print(sum([1 for i in range(len(sp1)-1) if find_champ(sp1,i) ]))

# # sp1 = [1,5,1,5,1] # 2

# # print(sum([1 for i in range(len(sp1)-1) if find_champ(sp1,i)  ]))

# # #закольцовываем список 

# # sp1 = [1,2,3,4,5]  # 1

# # print(sum([1 for i in range(len(sp1)) if find_champ2(sp1,i) ]))

# # Задача №43. Решение в группах Дан список чисел. Посчитайте, сколько в нем пар элементов, 
# # равных друг другу. Считается, что любые два элемента, равные друг другу образуют одну пару, 
# # которую необходимо посчитать. Вводится список чисел. Все числа списка находятся на разных строках. 

# # sp = [1,2,3,2,3,3,3,3] #2

# # # print(sp.count(3))
# # # print(sum([1 for i in sp if sp.count(i) % 2 == 0]) / 2)
# # print(sum( [sp.count(i) // 2 for i in set(sp) ]  ))


# # Задача №45. Решение в группах Два различных натуральных числа n и m называются дружественными, 
# # если сумма делителей числа n (включая 1, но исключая само n) равна числу m и наоборот. 
# # Например, 220 и 284 – дружественные числа. По данному числу k выведите все пары дружественных чисел, 
# # каждое из которых не превосходит k. Программа получает на вход одно натуральное число k, не превосходящее 10000. 
# # Программа должна вывести  все пары дружественных чисел, каждое из которых не превосходит k. Пары необходимо выводить 
# # по одной в строке, разделяя пробелами. Каждая пара должна быть выведена только один раз (перестановка чисел новую 
# # пару не дает). Ввод: 300 Вывод:  220 284

# def summa_dels(num):
#     res = 0
#     for i in range(1,num):
#         if num % i == 0:
#             res += i
#     return res


# # print(test := 5)

# # print(test + 10)

# k = int(input("До какого числа будем анализировать "))

# # res = []

# # for m in range(1, k+1):
# #     n = summa_dels(m)
# #     if summa_dels (n) == m and n > m:
# #         res.append( (n,m) )

# # print(res)

# print(res2 := [ (m,n)  for m in range(1, k+1) if summa_dels (n := summa_dels(m)) == m and n > m  ])


# # print( [ (m,summa_dels(m))  for m in range(1, k+1) if summa_dels (summa_dels(m)) == m and summa_dels(m) > m  ])
# print(res2)